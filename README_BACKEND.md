
                              ** 🅶🆈🅼🆂🅿🅰🅲🅴 **

#  𝐏𝐫𝐨𝐲𝐞𝐜𝐭𝐨 𝐟𝐢𝐧𝐚𝐥

## **📌 OBJETIVOS**

-  Construir una aplicación de página única (SPA) utilizando tecnologías como React, Node, Y MUI garantizando un rendimiento eficiente y una gestión integral de la aplicación.
-  Requisito TECH: Deploy - Asegurar que la aplicación esté desplegada en una plataforma accesible públicamente.

## ** 🚀  Aplicar Principios de Diseño UX/UI: **

-  Implementar Material-UI (MUI) y styled-components para crear una interfaz de usuario atractiva, coherente y altamente funcional.
-  Utilizar styled-components para la creación de estilos, asegurando una presentación visual coherente y agradable.
-  Incorporar react-material-ui-carousel para mejorar la experiencia del usuario al presentar imágenes y contenido visual.
- Requisito TECH: Auth de terceros integrada - Garantizar una experiencia de usuario fluida y segura al permitir registros y logins a través de terceros.

## ** 🚀  Integrar Tecnologías de Vanguardia: **

-  Utilizar herramientas modernas como Axios para realizar solicitudes HTTP de manera eficiente, facilitando la comunicación con el back-end.
-  Integrar react-router-dom para gestionar la navegación entre las diversas vistas de la aplicación de manera eficiente.
-  Requisito TECH: Pasarela de pagos - Implementar pagos seguros para productos y servicios utilizando MercadoPago.

## ** 🚀  Aplicar flujo de trabajo eficiente de GIT: **

-  Seguir buenas prácticas de Git, realizando commits significativos y descriptivos para mantener un historial claro y comprensible del desarrollo.
-  Utilizar el script "start" para servir la aplicación de manera local durante el desarrollo, asegurando un flujo de trabajo suave y colaborativo.
-  Requisito TECH: Dashboard admin - Facilitar la gestión de usuarios y productos mediante un panel de administrador.

## ** 🚀  Pruebas Prácticas: **

-  Implementar pruebas unitarias utilizando las herramientas proporcionadas por React y otras bibliotecas relevantes, garantizando la robustez y confiabilidad del código.
-  Asegurar la estabilidad y confiabilidad de la aplicación mediante pruebas de integración exhaustivas.
-  Requisito TECH: Borrado lógico - Implementar borrado lógico en productos, servicios y usuarios para una gestión más efectiva de los datos.

## ** 🚀  Cumplir con Historias de Usuarios: **

-  Desarrollar funcionalidades basadas en las User Stories definidas para satisfacer las necesidades específicas de los clientes y profesores del gimnasio.
-  Integrar mui-file-input para mejorar la experiencia de carga y manipulación de archivos, facilitando la interacción del usuario.
-  Requisito TECH: Reviews/puntuación - Permitir a los usuarios proporcionar opiniones y valoraciones sobre productos, clases e instructores.

## ** 🚀  Documentar el Flujo y la Lógica del Front-end: **

-  Proporcionar una explicación detallada del flujo y la lógica de construcción del front-end en el README, incluyendo la estructura y organización de los componentes, así como cualquier patrón de diseño utilizado.
-  Requisito TECH: Cloudinary/upload/bucket - Explicar cómo se utiliza Cloudinary para almacenar imágenes de productos y servicios.

## ** 🚀   Aprender y Mejorar Constantemente: **

-  Buscar oportunidades para aprender nuevas tecnologías y enfoques durante el desarrollo del proyecto, manteniéndose al tanto de las últimas actualizaciones y tendencias.
-  Estar abierto a la retroalimentación y realizar mejoras continuas en la aplicación, considerando las actualizaciones de las herramientas utilizadas y buscando siempre la excelencia en el desarrollo.
-  Requisito TECH: Filtros combinados - Mejorar la interfaz del usuario mediante filtros combinados para servicios y productos.

<br />

---

## **📋 SOBRE el levantamiento del back...**

Para asegurar el funcionamiento adecuado, sigue estos pasos:

1. Al iniciar el proyecto, ejecuta el comando:

npm install

Esto instalará todas las dependencias necesarias.

2. Posteriormente, inicia el servidor local ejecutando:

```bash
   npm start
```
Esta acción activará el manejo de datos locales y permitirá su utilización en diferentes partes de la aplicación.

Siguiendo estos pasos, tendrás acceso a los datos locales almacenados en el proyecto, optimizando el desarrollo y la interacción con la información necesaria.

de esta manera se te levantara el back
<br />

[nodemon] 3.0.1
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,cjs,json
[nodemon] starting `node index.js`
%s listening at 3001
**************************    GymSpace    ***********************
---

## 📖 ENUNCIADO GENERAL

Este proyecto tiene como propósito la creación de una aplicación, guiándonos por la descripción detallada de una plataforma de administración de gimnasios. La aplicación proporcionará una experiencia completa a los usuarios y facilitará la gestión eficiente de servicios y productos del gimnasio.


```bash

Objetivos Claves:
```

```bash

recordar que el back esta deployado link del deploy 
(https://gymspace-backend.onrender.com/)
```

## Registro y Gestión de Usuarios:

Permitir a los usuarios registrarse en la plataforma para una gestión centralizada de datos, incluyendo membresías, servicios, y productos.

## Administración de Membresías:

Brindar a los usuarios la capacidad de gestionar su membresía, desde renovaciones hasta cambios de plan, todo desde la comodidad de la plataforma.

## Adquisición de Servicios Adicionales:

Facilitar a los usuarios la compra de servicios adicionales como clases especiales o entrenamientos personalizados.

## Compras de Productos:

Ofrecer a los usuarios la posibilidad de explorar y adquirir productos relacionados con el gimnasio, creando una experiencia de compra integral.

## Exploración de Clases Disponibles:

Permitir a los usuarios ver las clases disponibles, verificar cupos y realizar registros de participación.

## Valoración y Retroalimentación:

Habilitar la valoración y reseñas por parte de los usuarios sobre clases, productos y entrenadores, contribuyendo a la mejora continua.

## Notificaciones Personalizadas:

Opción para que los usuarios reciban notificaciones por correo electrónico o mensajes push, manteniéndolos informados sobre eventos, recordatorios de pago y anuncios relevantes.

## Verificación de Disponibilidad en Clases:

Incorporar una función de verificación de disponibilidad antes de la inscripción en clases, garantizando una experiencia sin contratiempos.

## Gestión Eficiente de Usuarios:

Capacitar a los administradores con herramientas para gestionar eficazmente la información de los usuarios, incluyendo la capacidad de bloquear o desbloquear cuentas según sea necesario.

## Flexibilidad en Oferta de Servicios y Productos:

Facilitar a los administradores la capacidad de agregar, editar o eliminar servicios y productos, adaptando la oferta a las necesidades cambiantes del mercado.

## Supervisión y Gestión de Clases y Pagos:

Mantener un registro de la disponibilidad de clases, permitir inscripciones, y gestionar eficientemente los pagos, incluyendo recordatorios cuando sea necesario.

## Importante: 

- **Node.js / Express**: Backend construido con Node.js y el framework Express.
- **Sequelize**: ORM para interactuar con la base de datos PostgreSQL.

<br />

Es importante recodar que las dependencias las tendras una vez que ejecutes en la terminal 


```bash

npm install
```
<br />

---

## **📋 PARA COMENZAR...**

3. En la carpeta **`api`** deberás crear un archivo llamado: **`.env`** que tenga la siguiente forma:

   ```env
       DB_HOST =isabelle.db.elephantsql.com
       DB_USER =ugdgulic 
       DB_NAME = ugdgulic 
       DB_PASSWORD = 38J5zHz3ozwIpgzmXr1xvdFEU_seX1H3
   ``

4. Adicionalmente será necesario que crees, **desde psqlTools**, una base de datos llamada **`GymSpace`**. y configurar con los datos para que no exista problemas en el lavantamiento del back.

<br />

---

<br />

## **📁 INSTRUCCIONES**

### **🖱 BASE DE DATOS (db.js)**

db.js es el archivo encargado de establecer la conexión con la base de datos PostgreSQL y cargar los modelos necesarios para interactuar con ella. Aquí está la descripción de la lógica y funcionalidad del archivo:

Lógica y Funcionalidad de db.js:

Configuración de la Conexión a la Base de Datos:

dotenv se utiliza para cargar las variables de entorno desde un archivo .env.
Se utiliza la librería Sequelize para establecer la conexión con la base de datos PostgreSQL.
Las credenciales de la base de datos se obtienen desde las variables de entorno (DB_USER, DB_PASSWORD, DB_HOST, DB_NAME).
Se desactiva el logging de las consultas (logging: false) y se utiliza el driver nativo de Sequelize (native: false).
Definición de Modelos:

Se importan los modelos necesarios desde archivos externos (Users, Products, UserProducts, Services, UserServices, Coaches).
Cada modelo se ejecuta con la instancia de Sequelize para definir la estructura de la tabla correspondiente en la base de datos.
Relaciones entre Modelos:

Se establecen relaciones entre los modelos para reflejar las asociaciones en la base de datos.
Por ejemplo, la relación entre Users, UserServices, y Services se define con las funciones hasMany y belongsTo.
Exportación del Contexto de Base de Datos:

Se exportan todos los modelos y la instancia de Sequelize para que puedan ser utilizados en otras partes de la aplicación.
Flujo de Ejecución:

El archivo comienza cargando las variables de entorno y configurando la conexión con la base de datos.
Luego, importa los modelos necesarios y los ejecuta con la instancia de Sequelize para definir su estructura.
Se establecen las relaciones entre los modelos para reflejar la estructura de la base de datos.
Finalmente, se exportan los modelos y la instancia de Sequelize para su uso en otras partes de la aplicación.
Este archivo sirve como el punto central para la interacción con la base de datos, proporcionando un contexto unificado para acceder y manipular los datos.

tendra los siguientes models 

**`Coaches.js, Products.js, Sercives.js, UserProducts.js, Users.js, UserServices.js, Reviews.js, ServiceCoach.js`**

A continuaciòn se brindara la logica y funcionalidad de los models

 **📍 MODELO 1 | Coaches,js** 

Lógica y Funcionalidad:

Define el modelo Coaches que representa a los entrenadores.
Cada entrenador tiene un userID único, firstName, lastName, photo, y valuation que representa su calificación.
Se especifica la validación para asegurarse de que valuation esté en el rango de 1 a 10.
Se desactiva el registro de timestamp para este modelo (timestamps: false).

**📍 MODELO 2 | Products.js** 

Lógica y Funcionalidad:

Define el modelo Products que representa los productos disponibles.
Cada producto tiene un productID único, name, description, category, price, stockNow, brand, image, y status.
Se aplican validaciones para asegurar que price y stockNow sean mayores que cero.
Se desactiva el registro de timestamp para este modelo (timestamps: false).

**📍 MODELO 3 | Services.js** 

Lógica y Funcionalidad:

Define el modelo Services que representa los servicios ofrecidos.
Cada servicio tiene un serviceID único, name, description, category, price, startTime, duration, image, status, coachID, capacity, y areaID.
Se aplican validaciones para asegurar que price y capacity sean mayores que cero.
Se desactiva el registro de timestamp para este modelo (timestamps: false).

**📍 MODELO 4 | UserProducts.js** 

Lógica y Funcionalidad:

Define el modelo UserProducts que representa las transacciones de productos por parte de los usuarios.
Cada transacción tiene un userProductID único, valuation, qty, unitPrice, date, userID, productID, status, state, picture_url, currency_id, description, title, mp_payment_id, mp_status, y mp_merchant_order_id.
Se aplican validaciones para valuation, qty, y unitPrice para asegurar valores válidos.
Se establecen las relaciones con los modelos Users y Products.
Se desactiva el registro de timestamp para este modelo (timestamps: false).

**📍 MODELO 5 | Users.js**

Lógica y Funcionalidad:

Define el modelo Users que representa a los usuarios.
Cada usuario tiene un userID único, firstName, lastName, email, password, birth, gender, address, phone, contactPhone, photo, enrollmentDate, status, y systemRole.
Se aplican validaciones para email, password, gender, y systemRole.
Se desactiva el registro de timestamp para este modelo (timestamps: false).

**📍 MODELO 6 | UserServices.js**

Lógica y Funcionalidad:

Define el modelo UserServices que representa las transacciones de servicios por parte de los usuarios.
Cada transacción tiene un userServicesID único, startDate, finishDate, startTime, valuation, qty, unitPrice, date, status, userID, y serviceID.
Se aplican validaciones para valuation, qty, y unitPrice para asegurar valores válidos.
Se establecen las relaciones con los modelos Users y Services.
Se desactiva el registro de timestamp para este modelo (timestamps: false).
Cada modelo define la estructura de su respectiva tabla en la base de datos y especifica las validaciones necesarias para garantizar la integridad de los datos. Además, se establecen relaciones entre los modelos para reflejar las asociaciones en la base de datos. 

**📍 MODELO 7 | Reviews.js**
El modelo Reviews representa las revisiones o comentarios realizados por usuarios sobre los servicios que han adquirido. Aquí está la descripción de la lógica y funcionalidad del modelo:

reviewID: Identificador único de la revisión, generado automáticamente y utilizado como clave primaria.

userServicesID: Identificador único del servicio asociado a la revisión. Está vinculado al modelo UserServices, permitiendo establecer una relación entre la revisión y el servicio.

comment: Texto que contiene el comentario o revisión del usuario sobre el servicio. Es un campo obligatorio y no puede estar vacío.

display: Campo opcional que puede contener información sobre la visualización de la revisión. Puede utilizarse para indicar si la revisión debe mostrarse o no. Puede ser nulo.

Lógica y Funcionalidad:

Permite almacenar revisiones asociadas a servicios para recopilar opiniones de los usuarios.
La relación con UserServices garantiza que cada revisión esté vinculada a un servicio específico.
El campo display ofrece flexibilidad para gestionar la visibilidad de las revisiones.

**📍 MODELO 8 | ServiceCoach.js**
El modelo ServiceCoach establece una relación entre los servicios y los entrenadores (coaches). Aquí está la descripción de la lógica y funcionalidad del modelo:

serviceCoachID: Identificador único para la relación entre servicio y entrenador. Es generado automáticamente y se utiliza como clave primaria.

userID: Identificador único del usuario (entrenador) asociado al servicio. Está vinculado al modelo Users.

serviceID: Identificador único del servicio asociado al entrenador. Está vinculado al modelo Services.

Lógica y Funcionalidad:

Permite establecer una relación entre los servicios y los entrenadores que los ofrecen.
Cada registro en este modelo representa un servicio asociado a un entrenador específico.
Las claves foráneas userID y serviceID aseguran la integridad referencial al vincular este modelo con Users y Services respectivamente.
No utiliza marcas de tiempo para rastrear la creación o actualización de registros.

<br />
 --------
<br />

---

<br />

### **🖱 BACK-END**

el Back contara con las siguientes Rutas:

Lógica y Funcionalidad de las Rutas:
1. Ruta: Service.js
GET /

Lógica:
Obtiene todos los servicios disponibles.
Funcionalidad:
Devuelve un arreglo con información detallada de cada servicio.
GET /:id

Lógica:
Obtiene información detallada de un servicio específico por su ID.
Funcionalidad:
Devuelve un objeto con la información del servicio.
POST /

Lógica:
Crea un nuevo servicio.
Funcionalidad:
Recibe la información del nuevo servicio por el cuerpo de la solicitud y lo crea en la base de datos.
DELETE /:id

Lógica:
Elimina un servicio específico por su ID.
Funcionalidad:
Elimina el servicio correspondiente de la base de datos.
PUT /:id

Lógica:
Actualiza la información de un servicio específico por su ID.
Funcionalidad:
Recibe la información actualizada por el cuerpo de la solicitud y actualiza el servicio en la base de datos.
2. Ruta: UserProduct.js
GET /

Lógica:
Obtiene todos los productos asociados a usuarios.
Funcionalidad:
Devuelve un arreglo con información detallada de cada producto asociado a un usuario.
GET /:id

Lógica:
Obtiene información detallada de un producto asociado a usuario específico por su ID.
Funcionalidad:
Devuelve un objeto con la información del producto asociado a usuario.
POST /

Lógica:
Crea un nuevo producto asociado a usuario.
Funcionalidad:
Recibe la información del nuevo producto por el cuerpo de la solicitud y lo asocia al usuario en la base de datos.
PUT /:id

Lógica:
Actualiza la información de un producto asociado a usuario específico por su ID.
Funcionalidad:
Recibe la información actualizada por el cuerpo de la solicitud y actualiza el producto asociado al usuario en la base de datos.
DELETE /:id

Lógica:
Elimina un producto asociado a usuario específico por su ID.
Funcionalidad:
Elimina el producto asociado al usuario correspondiente de la base de datos.
3. Ruta: Users.js
GET /

Lógica:
Obtiene todos los usuarios.
Funcionalidad:
Devuelve un arreglo con información detallada de cada usuario.
GET /:id

Lógica:
Obtiene información detallada de un usuario específico por su ID.
Funcionalidad:
Devuelve un objeto con la información del usuario.
POST /

Lógica:
Crea un nuevo usuario.
Funcionalidad:
Recibe la información del nuevo usuario por el cuerpo de la solicitud y lo crea en la base de datos.
DELETE /:id

Lógica:
Elimina un usuario específico por su ID.
Funcionalidad:
Elimina el usuario correspondiente de la base de datos.
PUT /:id

Lógica:
Actualiza la información de un usuario específico por su ID.
Funcionalidad:
Recibe la información actualizada por el cuerpo de la solicitud y actualiza el usuario en la base de datos.
4. Ruta: userService.js
POST /
Lógica:
Crea un nuevo servicio asociado a usuario.
Funcionalidad:
Recibe la información del nuevo servicio por el cuerpo de la solicitud y lo asocia al usuario en la base de datos.

<br /> 

al tener las rutas su logica y funcionalidad vamos a iniciar con el app y el index como componentes raiz del proyecto (back) 

1. **app.js**
Lógica:

Configuración del servidor Express.
Uso de middlewares como body-parser, cookie-parser, morgan, y cors.
Configuración de rutas utilizando el router de ./routes/index.js.
Manejo de errores.
Funcionalidad:

Inicia un servidor Express.
Utiliza middlewares para procesar las solicitudes.
Define rutas y utiliza el enrutador principal.
Maneja errores y los muestra en la consola.
Exporta el servidor configurado.

**aqui pondre la funcionalidad y flujo de los controllers**

 **autho**
Funcionalidad:

Este controlador se encarga de obtener un token de autenticación utilizando el flujo de concesión de contraseñas (password Grant) con Auth0.
Utilice las credenciales del backend (usuario y contraseña) junto con las credenciales del cliente (client_id y client_secret) para obtener un token de acceso.
Retorna el token de acceso en caso de éxito, o un mensaje de error en caso contrario.
Flujo:

Recibe la solicitud con las creencias.
Realice una solicitud HTTP POST a la URL de Auth0 para obtener el token.
Si la solicitud es exitosa, retorna el token de acceso. En caso de error, devuelve un mensaje de error.

 **chat**
Funcionalidad:

Este controlador se encarga de realizar una solicitud a la API de OpenAI para obtener una respuesta del modelo de lenguaje GPT-3.
Utiliza el contenido de la
Retorna la respuesta generada por el modelo o un mensaje de error en caso de fallo.
Flujo:

Recibe la solicitud con los datos necesarios para interactuar con el modelo de lenguaje.
Realice una solicitud HTTP POST a la API de OpenAI con los datos proporcionados.
Si la solicitud es exitosa, retorna la respuesta generada por el modelo. En caso de error, devuelve un mensaje de error.

**Coaches**

**createCoach.controller**
Funcionalidad:

Crea un nuevo registro de entrenador en la base de datos.
Realiza validaciones de autorización y de datos proporcionados.
Retorna el nuevo entrenador creado o un mensaje de error.
Flujo:

Valida la autorización del usuario para crear un coach (solo permitido para roles de administrador).
Valida los datos proporcionados para el nuevo entrenador.
Crea el nuevo entrenador en la base de datos.
Retorna el entrenador creado o un mensaje de error.

**deleteCoachById.controller**
Funcionalidad:

Elimina un registro de entrenador de la base de datos por su ID.
Realiza validaciones de autorización y del formato del DNI.
Retorna un mensaje de éxito o un mensaje de error.
Flujo:

Valida la autorización del usuario para eliminar un coach (solo permitido para roles de administrador).
Valida el formato del documento de identidad proporcionado.
Busca el entrenador por su ID.
Si encuentra el entrenador, lo elimina de la base de datos.
Retorna un mensaje de éxito o un mensaje de error.

 **getCoachById.controller**
Funcionalidad:

Obtiene los detalles de un entrenador por su identificación.
Realiza validaciones del formato del ID.
Retorna los detalles del entrenador o un mensaje de error.
Flujo:

Valida el formato del documento de identidad proporcionado.
Busca el entrenador por su ID.
Si encuentra el entrenador, retorna sus detalles. En caso contrario, devuelve un mensaje de error.

 **getCoaches.controller**
Funcionalidad:

Obtiene la lista de autocares según los filtros y orden proporcionados.
Realiza filtrado y ordenamiento por nombre y valoración.
Retorna la lista de entrenadores o un mensaje de error.
Flujo:

Defina opciones de filtrado y ordenamiento según los parámetros de la solicitud.
Realice una consulta a la base de datos utilizando las opciones definidas.
Retorna la lista de entrenadores resultante o un mensaje de error.

 **updateCoach.controller**
Funcionalidad:

Actualiza los detalles de un entrenador por su ID.
Realiza validaciones de autorización, formato del DNI y datos proporcionados.
Retorna los detalles actualizados del entrenador o un mensaje de error.
Flujo:

Valida la autorización del usuario para actualizar un coach (permitido para el usuario o roles de administrador).
Valida el formato del documento de identidad proporcionado.
Busca el entrenador por su ID.
Valida los datos proporcionados para la actualización.
Si todo es válido, actualice los detalles del coach en la base de datos.
Retorna los detalles actualizados del entrenador o un mensaje de error.

**mailer**
Funcionalidad:

Este controlador se encarga de enviar correos electrónicos a los usuarios.
Utiliza la información proporcionada en el cuerpo de la solicitud para personalizar el correo.
Retorna un mensaje de éxito o error, dependiendo del resultado del envío del correo.

Flujo:

Recibe la solicitud con los datos necesarios para enviar un correo electrónico.
Valida la presencia de los campos requeridos en el cuerpo de la solicitud.
Prepara la información del usuario y el mensaje del correo.
Utiliza la función sendEmail del manejador de correo electrónico para enviar el correo.
En caso de éxito, retorna un mensaje indicando que el correo se ha enviado correctamente. En caso de error, retorna un mensaje de error.

 **payments/createOrder**

Funcionalidad:

Este controlador se encarga de crear una orden de pago utilizando MercadoPago.
Realiza validaciones de datos y autorización del usuario.
Crea preferencias de pago y registra la orden en la base de datos.

Flujo:

Recibe la solicitud con la información del usuario y los elementos de la orden.
Valida la presencia de los campos requeridos y el formato del ID del usuario.
Verifica la existencia y estado activo del usuario en la base de datos.
Valida y procesa los elementos de la orden mediante la función validateItems.
Utiliza la función createPreferences para obtener la respuesta de MercadoPago con el enlace de pago.
Crea una entrada de orden en la base de datos con la información de la orden y el ID externo proporcionado por MercadoPago.
Retorna la respuesta de MercadoPago con el enlace de pago.

 **payments/updateOrder**

Funcionalidad:

Este controlador se encarga de manejar las actualizaciones de estado de las órdenes de pago.
Actualiza el estado de las órdenes en la base de datos y notifica al usuario mediante correo electrónico.
Flujo:

Recibe la solicitud con los parámetros de actualización de la orden desde MercadoPago.
Utiliza la función updateOrderHandler para actualizar el estado de la orden en la base de datos.
Utiliza la función getOrderOwner para obtener la información del propietario de la orden.
Selecciona el mensaje de correo electrónico correspondiente según el estado de la orden (aprobada, pendiente o fallida).
Utiliza la función sendEmail para enviar un correo electrónico al usuario notificándole sobre el estado de la orden.
Redirige a la página principal de la aplicación.
 
 **products/deleteProductById**
Funcionalidad:

Elimina un producto de la base de datos según el ID proporcionado.
Retorna el producto eliminado si se encuentra, o un mensaje indicando que el producto no fue encontrado.
Flujo:

Recibe la solicitud con el ID del producto a eliminar.
Busca el producto en la base de datos utilizando el ID.
Si el producto no se encuentra, retorna un mensaje indicando que el producto no fue encontrado.
Si el producto se encuentra, lo elimina de la base de datos.
Retorna el producto eliminado.

 **products/getProductByID**
Funcionalidad:

Obtiene un producto de la base de datos según el ID proporcionado.
Retorna el producto encontrado o un mensaje indicando que el producto no fue encontrado.
Flujo:

Recibe la solicitud con el ID del producto a obtener.
Busca el producto en la base de datos utilizando el ID.
Si el producto no se encuentra, retorna un mensaje indicando que el producto no fue encontrado.
Si el producto se encuentra, retorna el producto.

 **products/getProducts**

Funcionalidad:

Obtiene la lista de todos los productos o aquellos que coincidan con un nombre específico.
Realiza una búsqueda de productos según el nombre proporcionado en la consulta.
Retorna la lista de productos encontrados.
Flujo:

Recibe la solicitud, verifica si se proporciona un nombre en la consulta.
Si se proporciona un nombre, realiza una búsqueda de productos que coincidan con el nombre.
Si no se proporciona un nombre, obtiene la lista completa de productos.
Retorna la lista de productos encontrados.

**products/postProducts**

Funcionalidad:

Crea un nuevo producto en la base de datos.
Realiza validaciones de atributos y verifica la no existencia previa del producto.
Retorna el producto creado o un mensaje indicando que el producto ya existe.
Flujo:

Recibe la solicitud con la información del nuevo producto.
Valida la presencia de todos los atributos requeridos y la ausencia de valores nulos o vacíos.
Verifica si ya existe un producto con el mismo nombre en la base de datos.
Si el producto no existe, crea el nuevo producto en la base de datos.
Retorna el producto creado o un mensaje indicando que el producto ya existe.

**products/updateProduct**

Funcionalidad:

Actualiza la información de un producto en la base de datos según el ID proporcionado.
Retorna el producto actualizado o un mensaje indicando que el producto no fue encontrado.
Flujo:

Recibe la solicitud con el ID del producto a actualizar y la nueva información.
Busca el producto en la base de datos utilizando el ID.
Si el producto no se encuentra, retorna un mensaje indicando que el producto no fue encontrado.
Si el producto se encuentra, actualiza su información en la base de datos.
Retorna el producto actualizado.

 **reviews/changeDisplay**
Funcionalidad:

Actualiza la propiedad display de una revisión en la base de datos según el ID proporcionado.
Retorna la revisión actualizada o un mensaje indicando que la revisión no fue encontrada.
Flujo:

Recibe la solicitud con el ID de la revisión a actualizar y la nueva información.
Busca la revisión en la base de datos utilizando el ID.
Si la revisión no se encuentra, retorna un mensaje indicando que la revisión no fue encontrada.
Si la revisión se encuentra, actualiza la propiedad display en la base de datos.
Retorna la revisión actualizada.

**reviews/createReview**
Funcionalidad:

Crea una nueva revisión en la base de datos.
Realiza validaciones de atributos y verifica la no existencia previa de la revisión.
Retorna la revisión creada o un mensaje indicando que la revisión ya existe.
Flujo:

Recibe la solicitud con la información de la nueva revisión.
Valida la presencia de todos los atributos requeridos y la ausencia de valores nulos o vacíos.
Verifica si ya existe una revisión con el mismo userServicesID en la base de datos.
Si la revisión no existe, crea la nueva revisión en la base de datos.
Retorna la revisión creada o un mensaje indicando que la revisión ya existe.

**reviews/deleteReview**
Funcionalidad:

Elimina una revisión de la base de datos según el ID proporcionado.
Retorna un mensaje indicando que la revisión fue eliminada o que no se encontró.
Flujo:

Recibe la solicitud con el ID de la revisión a eliminar.
Busca la revisión en la base de datos utilizando el ID.
Si la revisión no se encuentra, retorna un mensaje indicando que la revisión no fue encontrada.
Si la revisión se encuentra, la elimina de la base de datos.
Retorna un mensaje indicando que la revisión fue eliminada.

 **reviews/getReviews**
Funcionalidad:

Obtiene la lista de revisiones según los filtros proporcionados.
Realiza una búsqueda de revisiones en base a los filtros de usuario, servicio, tiempo y estado.
Retorna la lista de revisiones encontradas.
Flujo:

Recibe la solicitud con los filtros proporcionados.
Construye las opciones de consulta en base a los filtros recibidos.
Realiza una búsqueda de revisiones en base a los filtros.
Retorna la lista de revisiones encontradas.

 **services/createService**

Funcionalidad:

Crea un nuevo servicio en la base de datos.
Realiza validaciones de atributos y verifica la no existencia previa del servicio.
Asigna coaches al servicio a través de la tabla intermedia ServiceCoach.
Retorna el servicio creado o un mensaje indicando que el servicio ya existe.
Flujo:

Recibe la solicitud con la información del nuevo servicio.
Valida la presencia de todos los atributos requeridos y la ausencia de valores nulos o vacíos.
Realiza validaciones de tipos y formatos para algunos atributos (precio, hora de inicio, duración, etc.).
Valida la unicidad del nombre del servicio en la base de datos.
Crea el nuevo servicio en la base de datos.
Asigna los coaches al servicio a través de la tabla intermedia ServiceCoach.
Retorna el servicio creado o un mensaje indicando que el servicio ya existe.

 **services/deleteServiceById**
Funcionalidad:

Elimina un servicio de la base de datos según el ID proporcionado.
Retorna un mensaje indicando que el servicio fue eliminado o que no se encontró.
Flujo:

Recibe la solicitud con el ID del servicio a eliminar.
Valida que el ID tenga el formato correcto de UUID.
Busca el servicio en la base de datos utilizando el ID.
Si el servicio no se encuentra, retorna un mensaje indicando que el servicio no fue encontrado.
Si el servicio se encuentra, lo elimina de la base de datos.
Retorna un mensaje indicando que el servicio fue eliminado.

 **services/getAllServices**
Funcionalidad:

Obtiene la lista de servicios según los filtros proporcionados.
Realiza búsquedas y filtrados en base a los parámetros recibidos.
Aplica paginación y ordenamiento en los resultados.
Retorna la lista de servicios encontrados.
Flujo:

Recibe la solicitud con los filtros, paginación y ordenamiento proporcionados.
Construye las opciones de consulta en base a los filtros recibidos.
Realiza la búsqueda de servicios en base a las opciones configuradas.
Retorna la lista de servicios encontrados.

**services/getServiceById**
Funcionalidad:

Obtiene un servicio específico de la base de datos según el ID proporcionado.
Retorna el servicio encontrado o un mensaje indicando que no se encontró.
Flujo:

Recibe la solicitud con el ID del servicio a obtener.
Valida que el ID tenga el formato correcto de UUID.
Busca el servicio en la base de datos utilizando el ID.
Si el servicio no se encuentra, retorna un mensaje indicando que el servicio no fue encontrado.
Si el servicio se encuentra, lo retorna.

 **services/updateService**
Funcionalidad:

Actualiza la información de un servicio en la base de datos según el ID proporcionado.
Realiza validaciones de tipos, formatos y unicidad durante la actualización.
Retorna el servicio actualizado o un mensaje indicando un error.
Flujo:

Recibe la solicitud con el ID del servicio a actualizar y la nueva información.
Realiza validaciones de tipos y formatos para algunos atributos (precio, hora de inicio, duración, etc.).
Valida la unicidad del nombre del servicio en la base de datos.
Busca el servicio en la base de datos utilizando el ID.
Si el servicio no se encuentra, retorna un mensaje indicando que el servicio no fue encontrado.
Si el servicio se encuentra, actualiza la información en la base de datos.
Retorna el servicio actualizado o un mensaje indicando un error.

**user/createUser**
Funcionalidad:

Crea un nuevo usuario en la base de datos.
Realiza validaciones de atributos y verifica la no existencia previa del usuario.
Si el usuario se crea a través de Auth0, se utiliza la información proporcionada por Auth0.
Retorna el usuario creado o un mensaje indicando que el usuario ya existe.
Flujo:

Recibe la solicitud con la información del nuevo usuario.
Si el usuario se crea a través de Auth0, obtiene el ID de usuario y genera un UUID único.
Realiza validaciones de atributos y tipos de datos.
Si el usuario se crea a través de Auth0, verifica la no existencia del usuario por UUID o email.
Crea el nuevo usuario en la base de datos.
Retorna el usuario creado o un mensaje indicando que el usuario ya existe.

 **user/deleteUserById**

Funcionalidad:

Elimina un usuario de la base de datos según el ID proporcionado.
Verifica si el usuario que realiza la solicitud es un administrador antes de permitir la eliminación.
Retorna un mensaje indicando que el usuario fue eliminado o que no se encontró.
Flujo:

Recibe la solicitud con el ID del usuario a eliminar.
Obtiene el ID de usuario de Auth0 desde la información del token.
Verifica si el usuario que realiza la solicitud es un administrador.
Si el usuario no es un administrador, retorna un mensaje indicando que solo los administradores pueden realizar esta acción.
Si el usuario es un administrador, valida que el ID tenga el formato correcto de UUID.
Busca el usuario en la base de datos utilizando el ID.
Si el usuario no se encuentra, retorna un mensaje indicando que el usuario no fue encontrado.
Si el usuario se encuentra, lo elimina de la base de datos.
Retorna un mensaje indicando que el usuario fue eliminado.

**user/getAllUsers**
Funcionalidad:

Obtiene la lista de usuarios según los filtros proporcionados.
Realiza búsquedas y filtrados en base a los parámetros recibidos.
Aplica paginación y ordenamiento en los resultados.
Retorna la lista de usuarios encontrados.
Flujo:

Recibe la solicitud con los filtros, paginación y ordenamiento proporcionados.
Construye las opciones de consulta en base a los filtros recibidos.
Realiza la búsqueda de usuarios en base a las opciones configuradas.
Retorna la lista de usuarios encontrados.


**user/getUserById**
Funcionalidad:

Obtiene un usuario específico de la base de datos según el ID proporcionado.
Retorna el usuario encontrado o un mensaje indicando que no se encontró.
Flujo:

Recibe la solicitud con el ID del usuario a obtener.
Obtiene el ID de usuario de Auth0 desde la información del token.
Valida que el ID tenga el formato correcto de UUID.
Busca el usuario en la base de datos utilizando el ID.
Si el usuario no se encuentra, retorna un mensaje indicando que el usuario no fue encontrado.
Si el usuario se encuentra, lo retorna.

**user/getUserFavorites**
Funcionalidad:

Obtiene la lista de productos y servicios favoritos de un usuario.
Retorna un array con información resumida de los productos y servicios favoritos.
Flujo:

Recibe la solicitud con el ID del usuario cuyos favoritos se desean obtener.
Obtiene el ID de usuario de Auth0 desde la información del token.
Valida que el ID tenga el formato correcto de UUID.
Busca el usuario en la base de datos utilizando el ID.
Si el usuario no se encuentra, retorna un mensaje indicando que el usuario no fue encontrado.
Para cada producto favorito, obtiene la información resumida y agrega a un array con el tipo "prod".
Para cada servicio favorito, obtiene la información resumida y agrega a un array con el tipo "serv".
Combina ambos arrays y retorna la lista de productos y servicios favoritos.

**user/updateUser**
Funcionalidad:

Actualiza la información de un usuario en la base de datos según el ID proporcionado.
Realiza validaciones de tipos, formatos y unicidad durante la actualización.
Retorna el usuario actualizado o un mensaje indicando un error.
Flujo:

Recibe la solicitud con el ID del usuario a actualizar y la nueva información.
Obtiene el ID de usuario de Auth0 desde la información del token.
Valida que el ID tenga el formato correcto de UUID.
Busca el usuario en la base de datos utilizando el ID.
Si el usuario no se encuentra, retorna un mensaje indicando que el usuario no fue encontrado.
Realiza validaciones de tipos y formatos para algunos atributos (email, fecha de nacimiento, fecha de inscripción, etc.).
Si se actualiza el email, verifica la unicidad del email en la base de datos.
Si se actualiza el teléfono, verifica la unicidad del teléfono en la base de datos.
Si se actualizan favoritos, realiza la operación correspondiente (agregar o quitar).
Actualiza la información del usuario en la base de datos.
Retorna el usuario actualizado o un mensaje indicando un error.


**userProducts/createUserProduct**
Funcionalidad:

Crea un nuevo registro de producto para un usuario en la base de datos.
Realiza validaciones de datos y verifica la existencia de usuario y producto.
Retorna el registro creado o un mensaje de error.
Flujo:

Recibe la solicitud con la información del nuevo registro de producto para un usuario.
Realiza validaciones para garantizar que todos los campos requeridos estén presentes.
Busca el usuario y el producto en la base de datos utilizando los IDs proporcionados.
Si el usuario o el producto no se encuentran, retorna un mensaje indicando que no se encontró el usuario o el producto.
Crea el nuevo registro de producto para el usuario en la base de datos.
Retorna el registro creado o un mensaje de error.

 **userProducts/deleteUserProductById**
Funcionalidad:

Elimina un registro de producto para un usuario según el ID proporcionado.
Retorna un mensaje indicando que el registro fue eliminado o que no se encontró.
Flujo:

Recibe la solicitud con el ID del registro de producto a eliminar.
Busca el registro de producto en la base de datos utilizando el ID.
Si el registro de producto no se encuentra, retorna un mensaje indicando que no se encontró el registro.
Elimina el registro de producto de la base de datos.
Retorna un mensaje indicando que el registro fue eliminado.

 **userProducts/getAllUserProducts**
Funcionalidad:

Obtiene la lista de todos los registros de productos para usuarios según los filtros proporcionados.
Realiza búsquedas y filtrados en base a los parámetros recibidos.
Aplica paginación y ordenamiento en los resultados.
Retorna la lista de registros de productos encontrados.
Flujo:

Recibe la solicitud con los filtros, paginación y ordenamiento proporcionados.
Construye las opciones de consulta en base a los filtros recibidos.
Realiza la búsqueda de registros de productos en base a las opciones configuradas.
Retorna la lista de registros de productos encontrados.

 **userProducts/getUserProductById**
Funcionalidad:

Obtiene un registro de producto para un usuario según el ID proporcionado.
Retorna el registro de producto encontrado o un mensaje indicando que no se encontró.
Flujo:

Recibe la solicitud con el ID del registro de producto a obtener.
Busca el registro de producto en la base de datos utilizando el ID.
Si el registro de producto no se encuentra, retorna un mensaje indicando que no se encontró el registro.
Retorna el registro de producto encontrado.

**userProducts/updateUserProduct**
Funcionalidad:

Actualiza la información de un registro de producto para un usuario según el ID proporcionado.
Retorna el registro de producto actualizado o un mensaje de error.
Flujo:

Recibe la solicitud con el ID del registro de producto a actualizar y la nueva información.
Busca el registro de producto en la base de datos utilizando el ID.
Si el registro de producto no se encuentra, retorna un mensaje indicando que no se encontró el registro.
Actualiza la información del registro de producto en la base de datos.
Retorna el registro de producto actualizado o un mensaje de error.

**userServices/createUserService**
Funcionalidad:

Crea un nuevo registro de servicio para un usuario en la base de datos.
Realiza validaciones de datos y verifica la existencia de usuario y servicio.
Retorna el registro creado o un mensaje de error.
Flujo:

Recibe la solicitud con la información del nuevo registro de servicio para un usuario.
Realiza validaciones para garantizar que todos los campos requeridos estén presentes.
Busca el usuario y el servicio en la base de datos utilizando los IDs proporcionados.
Si el usuario o el servicio no se encuentran, retorna un mensaje indicando que no se encontró el usuario o el servicio.
Crea el nuevo registro de servicio para el usuario en la base de datos.
Retorna el registro creado o un mensaje de error.

**userServices/deleteUserServiceById**

Funcionalidad:

Elimina un registro de servicio para un usuario según el ID proporcionado.
Retorna un mensaje indicando que el registro fue eliminado o que no se encontró.
Flujo:

Recibe la solicitud con el ID del registro de servicio a eliminar.
Busca el registro de servicio en la base de datos utilizando el ID.
Si el registro de servicio no se encuentra, retorna un mensaje indicando que no se encontró el registro.
Elimina el registro de servicio de la base de datos.
Retorna un mensaje indicando que el registro fue eliminado.

**userServices/getAllUserServices**
Funcionalidad:

Obtiene la lista de todos los registros de servicios para usuarios según los filtros proporcionados.
Realiza búsquedas y filtrados en base a los parámetros recibidos.
Aplica paginación y ordenamiento en los resultados.
Retorna la lista de registros de servicios encontrados.
Flujo:

Recibe la solicitud con los filtros, paginación y ordenamiento proporcionados.
Construye las opciones de consulta en base a los filtros recibidos.
Realiza la búsqueda de registros de servicios en base a las opciones configuradas.
Retorna la lista de registros de servicios encontrados.

 **userServices/getUserServiceById**
Funcionalidad:

Obtiene un registro de servicio para un usuario según el ID proporcionado.
Retorna el registro de servicio encontrado o un mensaje indicando que no se encontró.
Flujo:

Recibe la solicitud con el ID del registro de servicio a obtener.
Busca el registro de servicio en la base de datos utilizando el ID.
Si el registro de servicio no se encuentra, retorna un mensaje indicando que no se encontró el registro.
Retorna el registro de servicio encontrado.

 **userServices/sendBulkEmails**
Funcionalidad:

Envía correos electrónicos masivos a los usuarios cuyos servicios cumplen con ciertos criterios.
Obtiene los servicios según los filtros proporcionados.
Retorna un mensaje indicando que los correos electrónicos fueron enviados correctamente.
Flujo:

Recibe la solicitud con los filtros proporcionados y la información del mensaje.
Obtiene los servicios según los filtros configurados.
Envía correos electrónicos masivos a los usuarios asociados a los servicios obtenidos.
Retorna un mensaje indicando que los correos electrónicos fueron enviados correctamente.

 **userServices/updateUserService**
Funcionalidad:

Actualiza la información de un registro de servicio para un usuario según el ID proporcionado.
Retorna el registro de servicio actualizado o un mensaje de error.
Flujo:

Recibe la solicitud con el ID del registro de servicio a actualizar y la nueva información.
Busca el registro de servicio en la base de datos utilizando el ID.
Si el registro de servicio no se encuentra, retorna un mensaje indicando que no se encontró el registro.
Actualiza la información del registro de servicio en la base de datos.
Retorna el registro de servicio actualizado o un mensaje de error.

**logica y funcionamiento de los otros compoentes - controller**

 **sendWsMessage.controller.js**
Funcionalidad:
Envía mensajes a través de WhatsApp utilizando la API de WhatsApp Business.
Logica:
Recepción de solicitud:

Recibe una solicitud HTTP con la información necesaria para enviar un mensaje a través de WhatsApp.
Validación de datos:

Verifica que la solicitud contenga la información necesaria, como el número de teléfono y el mensaje.
Generación de mensaje:

Construye el objeto de mensaje a enviar, que generalmente incluirá el número de teléfono de destino, el cuerpo del mensaje y cualquier otra información relevante.
Envío del mensaje:

Utiliza la API de WhatsApp Business para enviar el mensaje al número de teléfono proporcionado.
Maneja cualquier error o respuesta de la API y registra la información según sea necesario.
Respuesta HTTP:

Retorna una respuesta HTTP indicando el éxito o el fracaso del envío del mensaje.
Flujo:

Inicio:
La solicitud HTTP llega al endpoint correspondiente del servidor.
Validación:

Se verifica que la solicitud contenga la información necesaria y válida para enviar un mensaje.
Generación de mensaje:

Se crea un objeto de mensaje que contiene el número de teléfono de destino, el cuerpo del mensaje y cualquier otra información necesaria.
Envío del mensaje:

El sistema utiliza la API de WhatsApp Business para enviar el mensaje al número de teléfono especificado.
Manejo de errores:

Se manejan cualquier error o respuesta inesperada de la API de WhatsApp Business.
Respuesta HTTP:

Se retorna una respuesta HTTP indicando el resultado del intento de enviar el mensaje.

**logica y funcionamiento del Handler**


 **sendEmail**
Funcionalidad y Flujo:
Funcionalidad:

Envía correos electrónicos utilizando Nodemailer.
Utiliza una plantilla de mensaje para construir el contenido del correo.
Flujo:

Entrada:

userData: Contiene información del destinatario (nombre, apellido, correo).
messageData: Contiene información del mensaje (asunto, cuerpo, enlace).
Preparación del Mensaje:

Extrae la información necesaria de userData y messageData para construir el contenido del correo.
Utiliza una plantilla de mensaje para generar el cuerpo HTML del correo.
Configuración del Transporte:

Configura el transporte para el envío de correo utilizando Nodemailer.
La configuración incluye el host, puerto, credenciales de autenticación, y configuración TLS.
Creación del Mensaje:

Crea un objeto de mensaje con información como el remitente, destinatario, asunto y cuerpo del mensaje.

Envío del Correo:

Utiliza el transporte configurado para enviar el correo electrónico.
Retorna el resultado del envío.
Salida:

La función retorna una promesa que se resuelve con el resultado del envío del correo.


**createOrders**

 Funcionalidad y Flujo:
Funcionalidad:

Crea órdenes en la base de datos en función de los productos y servicios comprados.
Reduce el stock de productos disponibles y actualiza los asientos disponibles para servicios.
Flujo:

Entrada:

userId: Identificador del usuario que realiza la compra.
items: Lista de productos y servicios que se están comprando.
external_reference: Identificador único para asociar transacciones.
Iteración sobre Items:

Para cada ítem en la lista de compras:
Se obtiene el producto o servicio correspondiente de la base de datos.
Se verifica si es un producto o servicio.
Se reduce el stock del producto y se crea una entrada en la tabla UserProducts o UserServices según corresponda.
Salida:

No hay un resultado directo que se retorne; la función realiza cambios en la base de datos.

 **createPreferences**

Funcionalidad y Flujo:

Funcionalidad:

Crea preferencias para la integración con MercadoPago, generando el link de pago.
Asocia una transacción mediante un external_reference único.
Flujo:

Entrada:

req: Objeto de solicitud HTTP.
items: Lista de productos y servicios que se están comprando.
Construcción de Items para MercadoPago:

Se construye una lista de ítems adecuada para MercadoPago a partir de la información de los productos y servicios.
Configuración de Preferencias:

Se configuran las preferencias de pago, incluyendo las URLs de redirección y el external_reference.
Creación de Preferencias en MercadoPago:

Se utiliza la API de MercadoPago para crear las preferencias y obtener la respuesta.
Salida:

La función retorna un objeto que contiene la respuesta de MercadoPago y el external_reference.

 **getOrderOwner**
Funcionalidad y Flujo:

Funcionalidad:

Obtiene al propietario de una orden a partir del mp_external_reference.
Flujo:

Entrada:

mp_external_reference: Identificador único de transacción.
Búsqueda de Orden:

Se busca una orden en las tablas UserProducts o UserServices utilizando el mp_external_reference.
Obtención del Propietario:

Se obtiene al propietario de la orden mediante el identificador de usuario (userID).
Salida:

La función retorna un objeto de usuario (User).

 **updateOrder**
Funcionalidad y Flujo:

Funcionalidad:

Actualiza información de una orden con datos provenientes de MercadoPago.
Flujo:

Entrada:

data: Objeto con información proveniente de MercadoPago (id de pago, estado, id de orden, etc.).
Actualización de UserProducts y UserServices:

Se actualiza la información relacionada con la orden en las tablas UserProducts y UserServices utilizando el mp_external_reference.
Salida:

No hay un resultado directo que se retorne; la función realiza cambios en la base de datos.

 **validateItem**
Funcionalidad y Flujo:

Funcionalidad:

Valida la información de un ítem (producto o servicio) antes de procesar una orden.
Flujo:

Entrada:

item: Información del ítem a validar.
Validaciones:

Se realizan diversas validaciones, como:
Existencia y formato correcto de campos.
Validez de fechas para servicios.
Suficiente stock para productos.
Disponibilidad de asientos para servicios.
Salida:

No hay un resultado directo que se retorne; la función arroja errores si la validación no es exitosa.

 **validateItems**
Funcionalidad y Flujo:

Funcionalidad:

Valida la lista de ítems antes de procesar una orden.
Flujo:

Entrada:

items: Lista de productos y servicios a validar.
Iteración y Validación:

Se itera sobre cada ítem y se utiliza la función validateItem para validar individualmente.
Salida:

No hay un resultado directo que se retorne; la función arroja errores si la validación no es exitosa.

 **sendBulkEmail**
Funcionalidad y Flujo:
Funcionalidad:

Envía correos electrónicos a múltiples destinatarios con un mensaje común.
Flujo:

Entrada:

orders: Lista de órdenes de usuario que se utilizarán para obtener información del destinatario.
messageData: Contiene información del mensaje (asunto, cuerpo, enlace).
Iteración y Envío de Correos:

Para cada orden en la lista, se extrae la información del destinatario y se envía un correo electrónico utilizando la función sendEmail.

Salida:
No hay un resultado directo que se retorne; la función realiza el envío de correos electrónicos.

 **sendWsMessage**

Funcionalidad y Flujo:
Funcionalidad:

Envía mensajes a través de WhatsApp utilizando la API de Twilio.
Flujo:

Entrada:

userData: Contiene información del destinatario (número de teléfono).
messageData: Contiene información del mensaje (cuerpo).
Configuración del Mensaje:

Se configura el mensaje con el cuerpo y los números de teléfono del remitente y destinatario.
Envío del Mensaje:

Se utiliza la API de Twilio para enviar el mensaje a través de WhatsApp.
Salida:

La función retorna un objeto que contiene la información del mensaje enviado.


**la importancia de la carpeta utils**

La carpeta utils en la aplicación backend generalmente se va a utilizar para almacenar funciones y utilidades reutilizables en diversos lugares del código. Estas funciones pueden abordar tareas comunes, como validaciones, formateo de datos, manipulación de fechas, y otras operaciones que se repiten en diferentes partes de la aplicación. de esta manera se esta utilizando los archivos en la carpeta utils:

**Validaciones y Formateo:**

validateSimpleDate, isValidEmail, isValidPhoneNumber, isValidHourMinuteFormat, isValidUUID, isValidImageUrl, parseIntStrict, isStringLengthInRange, isValidPositiveInteger, isValidPositiveNumber: Estas funciones parecen estar destinadas a validar diferentes tipos de datos, como fechas, direcciones de correo electrónico, números de teléfono, etc. Son útiles para garantizar que los datos ingresados en la aplicación cumplan con ciertos criterios.

 **Funciones de Comparación:**

**arrayEquals:** Compara dos arrays para verificar si son iguales. Esto puede ser útil en situaciones donde necesitas verificar si dos conjuntos de datos son idénticos.
Funciones de Autenticación y Autorización:

**AuthUtils.js:** Contiene funciones relacionadas con la autenticación, como verificar si un usuario es un administrador y obtener un UUID único del usuario. Estas funciones son cruciales para la gestión de permisos y roles en la aplicación.
Otras Utilidades Generales:

 **toTitle:** Probablemente, esta función se utiliza para convertir cadenas de texto a formato de título.
Exportación Conjunta:

**index.js:** Combina todas las funciones de los archivos individuales en un solo objeto, facilitando su importación en otras partes del código. Esto permite que el código sea más modular y fácil de mantener.
En resumen, la carpeta utils centraliza funciones comunes y utilidades que pueden ser utilizadas en diferentes partes de la aplicación, promoviendo la reutilización del código y facilitando la mantenibilidad. Además, proporciona un lugar organizado para funciones que no necesariamente pertenecen

 **funcionalidad y flujo**

 **checkUserServices**
Funcionalidad:

Verifica los servicios de usuario que están a punto de expirar o tienen una notificación de días y envía correos electrónicos a los usuarios correspondientes.
Flujo:

Obtención de Datos:

Utiliza la consulta en la base de datos con el filtro para obtener los servicios de usuario que cumplen con las condiciones de expiración o notificación de días.
Utiliza la función getUserServicesOptions para construir las opciones de consulta.
Envío de Correos Electrónicos:

Utiliza la función sendBulkEmails para enviar correos electrónicos a los usuarios de los servicios obtenidos.
Proporciona un mensaje de prueba (messageData) con asunto, cuerpo y enlace.
Programación de Tarea:

Utiliza node-cron para programar la ejecución de checkUserServices en una fecha y hora específicas.
Salida:

No hay un resultado directo que se retorne; la función realiza envíos de correos electrónicos según las condiciones establecidas.

mails

**message.js**
Funcionalidad:

Define una plantilla HTML para mensajes de correo electrónico con variables como el nombre del usuario, el cuerpo del mensaje y un enlace.
Flujo:

Entradas:

firstName: Nombre del usuario.
lastName: Apellido del usuario.
html: Cuerpo del mensaje.
link: Enlace adjunto al mensaje.
Generación de HTML:

Utiliza los parámetros de entrada para construir el cuerpo HTML del mensaje.
Salida:

Retorna la plantilla HTML completa como una cadena de texto.

 **samples.js**
Funcionalidad:

Define ejemplos de mensajes de correo electrónico para diferentes estados de una orden.
Flujo:

Proporciona mensajes de ejemplo para situaciones de éxito, fallo y pendientes, así como mensajes relacionados con servicios a punto de expirar o ya expirados.

Carpeta de pagination:

 **setoffsetAndLimit.js**
Funcionalidad:

Establece el offset y el límite para la paginación de consultas.
Flujo:

Entradas:

page: Número de página.
limit: Tamaño de la página (opcional, por defecto es 10).
Validaciones:

Verifica que page y limit sean números positivos.
Cálculo de Offset y Límite:

Calcula el offset multiplicando el número de página menos uno por el límite.
Usa el límite proporcionado o un valor predeterminado de 10 si no se proporciona.
Salida:

Retorna un objeto con offset y limit para ser utilizado en consultas de paginación.

Carpeta de services:

 **setUpFilters.js**
Funcionalidad:

Configura los filtros para consultas de servicios.
Flujo:

Validaciones:

Verifica y valida formatos para campos como startTime, endTime, startDuration, endDuration, minCapacity, maxCapacity.
Configuración de Filtros:

Construye un objeto con filtros según los parámetros proporcionados.
Salida:

Retorna el objeto de filtros configurado.

 **setUpSorting.js**
Funcionalidad:

Configura el orden para consultas de servicios.
Flujo:

Configuración de Orden:

Utiliza las condiciones proporcionadas para determinar el orden en el que se deben devolver los resultados.
Salida:

Retorna una lista de campos y direcciones para ser utilizados en la cláusula order de la consulta.
Carpeta de users:

**setFilters.js**
Funcionalidad:

Configura los filtros para consultas de usuarios.
Flujo:

Validaciones:

Valida formatos para campos como startDate y endDate.
Configuración de Filtros:

Construye un objeto con filtros según los parámetros proporcionados.
Salida:

Retorna el objeto de filtros configurado.

 **setUpSorting.js**
Funcionalidad:

Configura el orden para consultas de usuarios.
Flujo:

Configuración de Orden:

Utiliza las condiciones proporcionadas para determinar el orden en el que se deben devolver los resultados.
Salida:

Retorna una lista de campos y direcciones para ser utilizados en la cláusula order de la consulta.

Carpeta de userServices:

 **arrayEquals.js**
Funcionalidad:

Compara dos arrays para determinar si son iguales.
Flujo:

Compara longitud y elementos de los arrays después de ordenarlos.

Salida:

Retorna true si los arrays son iguales, false de lo contrario.

 **uthUtils.js**
Funcionalidad:

Contiene funciones relacionadas con la autenticación y permisos de usuario.
Flujo:

isAdmin(userID): Verifica si un usuario tiene el rol de administrador.

getUUID(auth0User): Obtiene el UUID único del usuario a partir de la información de autenticación.

Salida:

Retorna true o false para isAdmin, y un UUID para getUUID.

 **index.js**
Funcionalidad:

Combina y exporta utilidades de varios archivos.
Flujo:

Utiliza el operador spread para combinar las funciones de múltiples archivos.

Salida:

Exporta un objeto con todas las funciones utilitarias combinadas.

**la importancia de la validaciones**

Integridad de Datos:

Las validaciones aseguran que los datos ingresados en la aplicación cumplan con ciertos criterios y formatos predefinidos.

Seguridad:

Validar los datos ayuda a prevenir ataques comunes, como inyecciones de código o manipulación de datos.

Experiencia del Usuario:

Proporcionan retroalimentación inmediata al usuario sobre la corrección de los datos ingresados, mejorando la experiencia del usuario.

Prevención de Errores:

Ayudan a evitar errores comunes o malentendidos al garantizar que los datos estén en el formato correcto antes de ser procesados.

Consistencia en la Base de Datos:

Contribuyen a mantener la consistencia de los datos en la base de datos al aplicar reglas específicas.

Conformidad con Requisitos de Negocio:

Las validaciones pueden garantizar que los datos cumplen con los requisitos específicos del negocio y del dominio de la aplicación.

Prevención de Vulnerabilidades:

Ayudan a prevenir la entrada de datos maliciosos que podrían explotar vulnerabilidades en el sistema.

Optimización del Rendimiento:

Al garantizar que los datos sean válidos desde el principio, se evitan procesamientos innecesarios y se optimiza el rendimiento.

Compatibilidad con Sistemas Externos:

En entornos donde se interactúa con sistemas externos, las validaciones aseguran que los datos cumplan con los estándares necesarios para la interoperabilidad.

Debugging Más Sencillo:

Las validaciones claras y específicas facilitan la identificación y corrección de errores, ya que indican exactamente dónde se produjo la falla.

Mantenimiento Simplificado:

Al centralizar las reglas de validación, se facilita el mantenimiento y la actualización de estas reglas en toda la aplicación.

**logica y funcionalidad de cada una de las validaciones**

**arrayEquals.js:**

Funcionalidad: Compara dos arrays para verificar si son iguales.
Lógica:
Verifica si la longitud de ambos arrays es la misma.
Realiza una copia y ordena ambos arrays.
Compara elemento por elemento para determinar si son iguales.

**AuthUtils.js:**

Funcionalidad: Contiene funciones relacionadas con la autenticación.
Lógica:
isAdmin(userID): Verifica si un usuario tiene el rol de "Admin".
getUUID(auth0User): Obtiene un UUID único para un usuario a partir de su ID de autenticación.

**index.js:**

Funcionalidad: Combina y exporta funciones de varios archivos en un solo objeto.
Lógica: Utiliza el operador spread (...) para combinar todas las funciones exportadas de archivos individuales.

**isStringLengthInRange.js:**

Funcionalidad: Verifica si la longitud de una cadena está dentro de un rango especificado.
Lógica: Compara la longitud de la cadena con los valores mínimos y máximos especificados.

**isValidEmail.js:**

Funcionalidad: Valida si una cadena sigue el formato básico de un correo electrónico.
Lógica: Utiliza una expresión regular para verificar si la cadena coincide con el formato de correo electrónico.

**isValidHourMinuteFormat.js:**

Funcionalidad: Verifica si una cadena sigue el formato "hora:minuto" (por ejemplo, "00:00").
Lógica: Utiliza una expresión regular para verificar si la cadena coincide con el formato de hora:minuto.

**isValidImageUrl.js:**

Funcionalidad: Valida si una cadena es una URL de imagen válida.
Lógica: Utiliza una expresión regular para verificar si la cadena coincide con un patrón de URL.

**isValidPhoneNumber.js:**

Funcionalidad: Valida si una cadena es un número de teléfono válido con al menos 8 dígitos.
Lógica: Utiliza una expresión regular para verificar si la cadena cumple con el formato de número de teléfono.

**isValidPositiveInteger.js:**

Funcionalidad: Valida si un número (o cadena) es un entero positivo.
Lógica: Verifica si es un entero, no es NaN y es mayor o igual a cero.

 **isValidPositiveNumber.js:**

Funcionalidad Valida si un número (o cadena) es un número positivo.
Lógica: Verifica si no es NaN y es mayor o igual a cero.

 **isValidUUID.js:**

Funcionalidad: Valida si una cadena es un UUID válido.
Lógica: Utiliza una expresión regular para verificar si la cadena coincide con el formato de UUID.

**parseIntStrict.js:**

Funcionalidad: Parsea un valor a entero o NaN de manera estricta.
Lógica: Utiliza parseInt, pero devuelve NaN si el resultado es NaN.

**toTitle.js:**

Funcionalidad: Convierte una cadena a formato de título (primera letra mayúscula).
Lógica: Toma la primera letra de la cadena y la convierte a mayúscula.

**validateSimpleDate.js:**

Funcionalidad: Valida si una cadena es una fecha en formato YYYY-MM-DD.
Lógica: Utiliza una expresión regular para verificar si la cadena cumple con el formato de fecha.

[**IMPORTANTE**]:
### **🖱 hay que aclarar que con el tiempo fueron desarrollando distintas y nuevas funciones en el back las cuales no estan documentadas en el Readme pero espero que puedan comprender su logica, funcionalidad y flujo de estas**

---

<div align="center">
<img src="./F1.svg" alt="" style="margin-top: 30px; width: 300px;" />
</div>